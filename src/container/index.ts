//NMP Imports
import {
  app,
  BrowserWindow,
  ipcMain,
  protocol,
  net,
  autoUpdater,
} from "electron";
import portscanner from "portscanner";
import path from "path";
import fs from "fs";
import isDev from "electron-is-dev";
import os from "os";
import log from "electron-log";
//Local Imports
import { startExpressServer } from "../server/server";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;

//Ensure Single Instance Only
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.quit();
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

app.whenReady().then(async () => {
  protocol.handle("static", (request) => {
    const fileUrl = request.url.replace("static://", "");
    const filePath = path.join(app.getAppPath(), ".webpack/renderer", fileUrl);
    return net.fetch(filePath);
  });

  //Create New Window
  console.log(os.hostname());
  const mainWindow = new BrowserWindow({
    height: 900,
    autoHideMenuBar: true,
    icon: "/knc.svg",
    webPreferences: {
      // preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: false,
    },
  });
  mainWindow.setAspectRatio(Math.sqrt(2));
  mainWindow.setMinimumSize(1232, 845);
  const runSheetWindow = new BrowserWindow({
    height: 1156,
    width: 1128,
    autoHideMenuBar: true,
    icon: "/knc.svg",
    show: isDev,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  const edgeLabelWindow = new BrowserWindow({
    height: 170,
    width: 870,
    autoHideMenuBar: true,
    icon: "/knc.svg",
    show: isDev,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  //Get Available Port for Express DB
  process.env.EXPRESSPORT = await getAvailablePort();

  ipcMain.on("get-express-port", (event) => {
    event.returnValue = process.env.EXPRESSPORT;
  });
  ipcMain.on("get-hostname", (event) => {
    event.returnValue = os.hostname();
  });
  ipcMain.on("get-app-version", (event) => {
    event.returnValue = app.getVersion();
  });
  ipcMain.on("get-printers", async function (event) {
    const contents = mainWindow.webContents;
    const printers = await contents.getPrintersAsync();
    event.returnValue = printers;
  });
  ipcMain.on("restartApp", () => {
    console.log("Restarting App");
    autoUpdater.quitAndInstall();
  });
  ipcMain.on("print-run-sheet", (event, arg) => {
    console.log(arg);
    const contents = runSheetWindow.webContents;

    // Using the callback of contents.print to handle async operation
    contents.print(
      { dpi: { horizontal: 600, vertical: 600 }, ...arg },
      (success, errorType) => {
        console.log("Print Result:", success, errorType);

        // Sending a reply back to the renderer process with the result
        if (success) {
          event.reply("print-run-sheet-reply", { success: true });
        } else {
          console.log("Print Error:", errorType);
          event.reply("print-run-sheet-reply", {
            success: false,
            error: errorType,
          });
        }
      }
    );
  });

  ipcMain.on("print-labels", (event, arg) => {
    console.log(arg);
    const contents = edgeLabelWindow.webContents;

    // Using the callback of contents.print to handle async operation
    contents.print(
      { dpi: { horizontal: 600, vertical: 600 }, ...arg },
      (success, errorType) => {
        console.log("Print Result:", success, errorType);

        // Sending a reply back to the renderer process with the result
        if (success) {
          event.reply("print-labels-reply", { success: true });
        } else {
          console.log("Print Error:", errorType);
          event.reply("print-labels-reply", {
            success: false,
            error: errorType,
          });
        }
      }
    );
  });

  //Sync For Main Window
  ipcMain.on("update-store", (event, storeSnapshot) => {
    const secondaryWindows = [runSheetWindow, edgeLabelWindow];
    secondaryWindows.forEach((win) => {
      if (win && !win.isDestroyed()) {
        console.log("Sending Store Update to Window");
        win.webContents.send("store-updated", storeSnapshot);
      }
    });
  });

  //if (process.mainModule.filename.indexOf('app.asar') !== -1) {
  if (__filename.indexOf("app.asar") !== -1) {
    process.env.PATHFORWSF = path.join(
      path.dirname(app.getPath("exe")),
      "./resources/vbs"
    );
    process.env.ADODBPATH = "./resources/adodb.js";
  }

  //Start Express Server
  await startExpressServer();

  //Load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  runSheetWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + "#/print-run-sheet");
  edgeLabelWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY + "#/print-labels");
  //Set Dev Tools
  if (isDev) {
    // await session.defaultSession.loadExtension(reactDevToolsPath);
    mainWindow.webContents.openDevTools({
      mode: "detach",
      title: "Main Window",
    });
    runSheetWindow.webContents.openDevTools({
      mode: "detach",
      title: "Print Run Sheet",
    });
    edgeLabelWindow.webContents.openDevTools({
      mode: "detach",
      title: "Edge Label",
    });
  }

  app.on("before-quit", () => {
    console.log("Before Quit");
    if (mainWindow) mainWindow.destroy();
    if (runSheetWindow) runSheetWindow.destroy();
  });

  app.on("window-all-closed", () => {
    console.log("Window All Closed");
    if (process.platform !== "darwin") {
      app.quit();
    }
  });

  mainWindow.on("closed", () => {
    console.log("Main Window Closed");
    if (mainWindow) mainWindow.destroy();
    if (runSheetWindow) runSheetWindow.destroy();
    if (runSheetWindow) edgeLabelWindow.destroy();
    app.quit();
  });

  if (!isDev) {
    // Set timed interval to check for updates every 60000 milliseconds (1 minute)
    setInterval(() => {
      try {
        const server = "https://knc-run-sheet-be90a93ca32b.herokuapp.com";
        const url = `${server}/update/${process.platform}/${app.getVersion()}`;
        autoUpdater.setFeedURL({ url });
        autoUpdater.checkForUpdates();
      } catch (err) {
        log.error("Error checking for updates:", err);
      }
    }, 60000);

    autoUpdater.on("error", (error) => {
      log.error("Error in auto-updater:", error);
    });

    autoUpdater.on("update-downloaded", (event, releaseNotes, releaseName) => {
      try {
        let message = process.platform === "win32" ? releaseNotes : releaseName;
        mainWindow.webContents.send("updateDownloaded", message);
      } catch (err) {
        log.error("Error handling update-downloaded event:", err);
        mainWindow.webContents.send("autoUpdateError", err);
      }
    });
  }

  console.log("Electron Main Complete");
});

const getAvailablePort = async () => {
  try {
    const portNumber = await portscanner.findAPortNotInUse(25000, 35000);
    return String(portNumber);
  } catch (error) {
    console.log("Error in getAvailablePort:", error);
    const portNumber = String(25000);
    return portNumber;
  }
};
